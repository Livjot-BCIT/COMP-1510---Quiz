{
  "08_01": "Linear search checks each element in a list one by one, stopping when it finds the target or reaches the end, making it simple but not always efficient.",
  "08_02": "Linear search must look through n elements in the average case, resulting in a time complexity of O(n).",
  "08_03": "Binary search only works if the list is sorted, because it repeatedly divides the search space in half, assuming order.",
  "08_04": "Binary search reduces the number of items to search by half each time, resulting in a logarithmic O(log n) time complexity.",
  "08_05": "Selection sort finds the minimum element from the unsorted part and moves it to the end of the sorted part, repeating this process.",
  "08_06": "Selection sort uses two nested loops and always does n^2 comparisons in the worst case, so its time complexity is O(n^2).",
  "08_07": "Bubble sort works by repeatedly comparing and swapping adjacent elements if they're in the wrong order, moving larger values to the end each pass.",
  "08_08": "Insertion sort is efficient for small or nearly sorted lists because it minimizes shifts and comparisons when elements are already close to sorted.",
  "08_09": "Each pass in insertion sort takes an element and inserts it into the correct position among the sorted elements to its left.",
  "08_10": "Bubble sort may require multiple passes over the array, leading to a worst-case time complexity of O(n^2).",
  "08_11": "Binary search is most efficient for sorted arrays because it divides the array in half each time, greatly reducing the number of comparisons.",
  "08_12": "Binary search does NOT require unique values in the array; it only requires the array to be sorted and accessible by index.",
  "08_13": "Collections.sort(list) is the standard Java method to sort an ArrayList in ascending order.",
  "08_14": "You can use a for loop from index 0 to length-1 to access and print each element of an array.",
  "08_15": "To find the maximum in an array, loop through each element and update the max variable if a larger value is found.",
  "08_16": "Sorting {1,3,2} results in {1,2,3}, so arr[0] is 1.",
  "08_17": "Selection sort is not stable; it may change the order of equal elements, while others like bubble, insertion, and merge sort are stable.",
  "08_18": "A linear search loops through the array and checks if each element matches the target, returning the index or true if found.",
  "08_19": "Selection sort always performs the same number of comparisons, regardless of array content, due to its nested loop structure.",
  "08_20": "An O(n) algorithm doubles in run time when the input size doubles, indicating a linear relationship.",
  "08_21": "In-place sorting means the array is rearranged without needing much extra memory, just a few variables for swapping.",
  "08_22": "Selection sort does the fewest swaps because it only swaps once per pass, while others may swap more often.",
  "08_23": "Binary search is faster than linear search, but only when the array is sorted.",
  "08_24": "Optimized bubble sort can end early if a pass completes without swaps, which is helpful for nearly sorted data.",
  "08_25": "Searching an unsorted array requires checking every element, so the best possible time complexity is O(n).",
  "08_26": "Arrays.sort(arr) sorts the array in ascending order by default.",
  "08_27": "Insertion sort is the most efficient for data that is already sorted or nearly sorted, as it minimizes unnecessary work.",
  "08_28": "Merge sort is a divide and conquer algorithm, commonly taught in higher-level courses and used for efficient sorting.",
  "08_29": "Binary search is O(log n), not linear-time; the others require O(n) time.",
  "08_30": "Poorly written sorting algorithms might skip elements, sort incorrectly, or use too much memory/time, causing errors or inefficiency.",
  "08_31": "Tracing code means following each step and variable value to understand how the algorithm works and predict its output.",
  "08_32": "To check if an array is sorted, compare each element to the next; if any element is greater than the next, the array is not sorted.",
  "08_33": "If the middle element is less than the target, you only need to search the right half (higher indices) of the sorted array.",
  "08_34": "ArrayLists can change size as you add or remove items, which is helpful when you don't know the final size in advance.",
  "08_35": "Recursion is powerful for problems that can be broken into smaller versions of themselves, making some algorithms easier to write and understand.",
  "08_36": "O(log n) algorithms grow much more slowly than O(n) as input size increases, making them more efficient for large n.",
  "08_37": "This code implements binary search, which is efficient for sorted arrays and reduces the search space each step.",
  "08_38": "Binary search is ideal for efficiently finding a missing number in a sorted sequence by exploiting the ordering.",
  "08_39": "Sorting {4,2,3} gives {2,3,4}, so arr[2] is 4.",
  "08_40": "Big-O notation describes the growth rate of an algorithm's running time as the input size increases.",
  "08_41": "The best case for linear search is when the target is the first element, requiring only one comparison.",
  "08_42": "The worst case for binary search is when the item is not found, requiring log2(n) comparisons as the search space is repeatedly halved.",
  "08_43": "A sentinel value is a special marker used in arrays to signal the end of valid data, often used in algorithms to simplify checks.",
  "08_44": "Printing the array backwards using a reverse-indexed loop outputs the values in reverse order: 8 6 4 2.",
  "08_45": "Selection sort does n(n-1)/2 comparisons because for each element, it compares to every other unsorted element.",
  "08_46": "A trace table is a tool for algorithm analysis that helps track the values of variables at each step of execution.",
  "08_47": "Incrementing by 2 in the for loop prints every other element, starting with index 0: 1 3 5.",
  "08_48": "Arrays.binarySearch returns the index of the found value; since 2 is at index 1, it returns 1.",
  "08_49": "Sorting {5,4,3,2,1} gives {1,2,3,4,5}, so the last element is 5.",
  "08_50": "ArrayList's contains(x) checks if x is present in the list, making searching easy for objects as well as primitive-wrapped values.",
  "08_51": "Exception handling lets you deal with unexpected errors without your whole program crashing. It allows you to handle the error, show a message, or recover from the issue gracefully, improving user experience and program reliability.",
  "08_52": "The 'catch' keyword is used in Java to catch exceptions thrown by code in the 'try' block. It lets you specify how your program should respond if an exception occurs.",
  "08_53": "To open a text file for reading, you usually use a Scanner connected to a File object, like 'Scanner input = new Scanner(new File(\"data.txt\"));'. This is a standard and safe way to read text files line by line.",
  "08_54": "The 'finally' block always runs after try and catch blocks, no matter if an exception was thrown or not. It's commonly used to close resources (like files) to ensure cleanup happens.",
  "08_55": "Inheritance is a fundamental concept in Java that lets one class (the subclass) inherit variables and methods from another class (the superclass), making code reuse easier and supporting OOP principles."
}
