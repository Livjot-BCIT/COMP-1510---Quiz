{
  "07_01": "An assembly instruction usually has two parts: the opcode (which specifies the operation) and the operands (which specify the data or locations to operate on).",
  "07_02": "Assembly language is low-level, close to machine code, unlike high-level languages such as Python or Java.",
  "07_03": "An assembler converts assembly language into machine code that the CPU can execute.",
  "07_04": "Directives like `.data`, `.text`, and `.word` give instructions to the assembler, not the CPU. They define sections, storage, and constants.",
  "07_05": "Labels are symbolic names marking memory addresses so instructions can refer to them instead of raw addresses.",
  "07_06": "`ADD R1, R2, R3` generally means add the values in R2 and R3, and store the result in R1.",
  "07_07": "The Program Counter (PC) keeps track of the memory address of the next instruction to execute.",
  "07_08": "The Instruction Register holds the actual instruction currently being executed, not the address of the next instruction.",
  "07_09": "MOV, LOAD, and STORE are data movement instructions used to transfer data between registers and memory.",
  "07_10": "`CMP` compares two values by subtracting one from the other and sets condition flags without storing the result.",
  "07_11": "Immediate addressing mode includes the actual constant value in the instruction, not an address.",
  "07_12": "Immediate addressing directly encodes the operand value within the instruction itself.",
  "07_13": "In direct addressing, the operand field contains the memory address of the data to be accessed.",
  "07_14": "Indirect addressing uses a pointer (register or memory location) that holds the actual address of the operand.",
  "07_15": "Control flow instructions like JMP, CALL, and RET change the order of execution, unlike MOV which moves data.",
  "07_16": "`RET` returns execution to the address saved when the subroutine was called.",
  "07_17": "In most architectures, the stack grows toward lower memory addresses, meaning it 'grows down' in memory.",
  "07_18": "`PUSH` saves a value onto the stack and adjusts the stack pointer.",
  "07_19": "`POP` removes the top value from the stack, stores it in a register, and moves the stack pointer accordingly.",
  "07_20": "A conditional jump is executed only when a specific condition (based on status flags) is met.",
  "07_21": "The zero flag is set when the result of an operation is zero.",
  "07_22": "The carry flag indicates that an unsigned arithmetic result exceeded the capacity of the register.",
  "07_23": "Indexed addressing calculates the effective address by adding a constant offset to a register's value.",
  "07_24": "A base register often points to a memory block or start of a data structure and is used for indexed addressing.",
  "07_25": "Instruction execution time varies; complex instructions can take multiple clock cycles.",
  "07_26": "MOV (or similar) instructions are used to load values from memory into registers.",
  "07_27": "The STORE instruction writes the contents of a register to a specified memory address.",
  "07_28": "The instruction cycle typically has fetch, decode, and execute phases; execute may perform many types of operations, not just arithmetic.",
  "07_29": "The fetch phase retrieves the instruction from memory and places it into the Instruction Register.",
  "07_30": "The Program Counter is incremented during the fetch phase, not the decode phase.",
  "07_31": "The overflow flag is used to detect when signed arithmetic exceeds the representable range.",
  "07_32": "Conditional jumps check status flags set by previous instructions to decide whether to branch.",
  "07_33": "JMP is an unconditional branch that always transfers control to the target address.",
  "07_34": "JE, JNE, and JG are examples of conditional jumps; MOV is not a branching instruction.",
  "07_35": "Assembly allows low-level hardware control, such as manipulating registers and device I/O directly.",
  "07_36": "A subroutine is a reusable block of code designed to perform a specific task.",
  "07_37": "CALL pushes the return address onto the stack and jumps to the subroutine's address.",
  "07_38": "When a subroutine is called, the return address is pushed onto the stack first so execution can return later.",
  "07_39": "Subroutines promote code reuse, make maintenance easier, and can reduce overall program size.",
  "07_40": "Parameters can be passed via registers, the stack, or memory, not just registers.",
  "07_41": "PC-relative addressing adds an offset to the current value of the Program Counter to find the target address.",
  "07_42": "PC-relative addressing is commonly used for branches so code can be position-independent.",
  "07_43": "ADD, SUB, and MUL perform arithmetic; JMP is a control flow instruction, not arithmetic.",
  "07_44": "The AND instruction performs a bitwise AND between its operands.",
  "07_45": "Bitwise operations manipulate individual bits rather than entire numeric values in a mathematical sense.",
  "07_46": "NOT flips every bit of the operand, turning 1s into 0s and 0s into 1s.",
  "07_47": "Shift operations can multiply/divide by powers of two and rotate bits for algorithms like encryption.",
  "07_48": "Logical shifts do not preserve the sign bit; arithmetic shifts can preserve it for signed numbers.",
  "07_49": "MOV Rn, #0 sets a register to zero quickly by loading the immediate value 0.",
  "07_50": "Assembly syntax varies between architectures (e.g., x86 vs ARM), so it is not standardized."
}
