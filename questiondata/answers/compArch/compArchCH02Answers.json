{
  "02_01": "The Control Unit issues timing and control signals that coordinate the fetch-decode-execute cycle, ensuring each stage occurs in the correct order.",
  "02_02": "The Program Counter holds the address of the next instruction to fetch, enabling sequential instruction execution unless modified by control flow changes.",
  "02_03": "The Instruction Register stores the fetched instruction so it can be decoded and executed.",
  "02_04": "The MAR stores a memory address to be accessed, while the MBR (or MDR) holds the data being transferred to or from that address.",
  "02_05": "The instruction cycle typically follows the Fetch → Decode → Execute sequence, where each stage feeds into the next.",
  "02_06": "The Control Unit generates control signals, decodes instructions, and manages register transfers during instruction execution.",
  "02_07": "A hardwired control unit cannot be modified by changing a microprogram, as it uses fixed logic for instruction control.",
  "02_08": "Microprogrammed control units are easier to modify than hardwired ones because changes can be made by altering the microcode.",
  "02_09": "The accumulator temporarily stores the result of an arithmetic or logic operation before it's written to memory or another register.",
  "02_10": "The CPU datapath handles data processing and movement between functional units like the ALU, registers, and memory.",
  "02_11": "The control bus carries control signals, not actual data, so it is not responsible for transferring data between CPU and memory.",
  "02_12": "The address bus carries the memory address from the CPU to the memory unit so data can be read or written.",
  "02_13": "The ALU performs arithmetic and logical operations on data as part of instruction execution.",
  "02_14": "The MAR is a special-purpose register for addresses and is not considered a general-purpose register.",
  "02_15": "The stack pointer keeps track of the top location in the stack, used for managing function calls and local variables.",
  "02_16": "General-purpose registers provide flexibility for a wide range of operations without being tied to one specific function.",
  "02_17": "RISC architectures use simple instructions designed to execute in a single cycle for efficiency and predictability.",
  "02_18": "CISC architectures generally offer more addressing modes than RISC to increase instruction flexibility.",
  "02_19": "CISC's complex instructions allow more work to be done in a single instruction, reducing code size.",
  "02_20": "RISC processors commonly use a load/store architecture where only load and store instructions access memory.",
  "02_21": "The Program Counter stores the address of the instruction currently being fetched from memory.",
  "02_22": "Load/store architectures restrict memory access to explicit load and store instructions for simpler CPU design.",
  "02_23": "Word size refers to the number of bits a CPU can process in one operation and affects performance and memory addressing.",
  "02_24": "The opcode specifies the operation to be carried out by the CPU within an instruction.",
  "02_25": "Immediate addressing mode includes the operand's value directly in the instruction.",
  "02_26": "Indexed addressing calculates the effective address by adding a constant offset to a register's value.",
  "02_27": "In indirect addressing, the instruction provides an address that points to another address containing the actual operand.",
  "02_28": "Direct addressing specifies the operand's memory location directly within the instruction.",
  "02_29": "Jump instructions alter program control by changing the execution flow to a new address.",
  "02_30": "Conditional branch instructions only change execution flow when a specified condition or flag is met.",
  "02_31": "A power flag is not standard in a CPU status register; typical flags include zero, carry, and overflow.",
  "02_32": "The zero flag is set when the result of the last operation is zero.",
  "02_33": "The carry flag indicates that an arithmetic operation produced a carry out of the most significant bit.",
  "02_34": "Pipelining allows overlapping of instruction stages so multiple instructions can be in progress simultaneously.",
  "02_35": "Data hazards occur when an instruction needs a result from a prior instruction that hasn't yet completed.",
  "02_36": "Structural hazards occur when two instructions compete for the same hardware resource in the CPU pipeline.",
  "02_37": "Branch prediction attempts to guess the outcome of a branch to reduce control hazard penalties.",
  "02_38": "Superscalar CPUs can issue and execute multiple instructions per clock cycle for higher throughput.",
  "02_39": "Out-of-order execution improves performance by running independent instructions as soon as resources are available, regardless of original order.",
  "02_40": "In-order execution processes instructions in their original order, simplifying CPU design but potentially lowering performance.",
  "02_41": "The opcode field of an instruction specifies which operation the CPU should perform.",
  "02_42": "In fixed-length formats, all instructions have the same bit size, simplifying decoding.",
  "02_43": "RISC's simpler instructions can lead to larger code size compared to CISC, but offer speed advantages in execution.",
  "02_44": "CISC generally has more complex instructions than RISC, often allowing a single instruction to take multiple cycles.",
  "02_45": "RISC aims for a smaller set of simpler instructions, optimized for fast execution, often completing in one clock cycle.",
  "02_46": "CISC processors often rely on microcode to execute complex, multi-step instructions.",
  "02_47": "Pipelining improves throughput by overlapping instruction execution and making better use of CPU resources.",
  "02_48": "The ISA is the contract between hardware and software, defining the supported instructions and how software communicates with hardware."
}
