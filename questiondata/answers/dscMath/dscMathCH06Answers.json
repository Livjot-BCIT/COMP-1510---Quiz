{
  "06_01": "A graph consists of vertices (points) and edges (connections between points).",
  "06_02": "The points in a graph are called vertices or nodes.",
  "06_03": "An edge in an undirected graph connects two vertices, with no direction.",
  "06_04": "The degree is the count of edges incident (connected) to a vertex.",
  "06_05": "A tree is a connected graph with no cycles.",
  "06_06": "A path is a sequence of edges connecting a series of distinct vertices.",
  "06_07": "A connected graph has a path between every pair of vertices.",
  "06_08": "An adjacency matrix is a table showing which vertices are connected by edges.",
  "06_09": "A cycle is a path that starts and ends at the same vertex, with all edges and all other vertices used only once.",
  "06_10": "A simple graph has no loops and no multiple edges between the same pair of vertices.",
  "06_11": "A complete graph with n vertices has n(n-1)/2 edges, since every pair of vertices is connected.",
  "06_12": "A spanning tree is a subgraph that is a tree including all vertices of the original graph.",
  "06_13": "Breadth-First Search (BFS) visits all vertices in a level-by-level order from a starting vertex.",
  "06_14": "Depth-First Search (DFS) typically uses a stack, exploring as far as possible along each branch before backtracking.",
  "06_15": "A tree is an acyclic connected graph, so checking for cycles confirms this property.",
  "06_16": "An Eulerian path uses every edge exactly once in a graph.",
  "06_17": "A graph has an Eulerian circuit if and only if every vertex has an even degree.",
  "06_18": "A Hamiltonian path visits every vertex exactly once.",
  "06_19": "A tree has exactly one path between any pair of vertices; this is a defining property.",
  "06_20": "Dijkstra's Algorithm finds shortest paths in a weighted graph from a starting vertex.",
  "06_21": "The root is the unique node in a tree with no parent.",
  "06_22": "A leaf in a tree is a node with no children (no edges leading out).",
  "06_23": "A planar graph can be drawn without edges crossing on a plane.",
  "06_24": "A weighted graph assigns values (weights or costs) to each edge.",
  "06_25": "An adjacency list lists which vertices are neighbors (connected by edges) for each vertex.",
  "06_26": "A simple undirected graph with n vertices has at most n(n-1)/2 edges.",
  "06_27": "A bipartite graph's vertices can be split into two sets so that all edges go between, not within, sets.",
  "06_28": "A self-loop is an edge that connects a vertex to itself.",
  "06_29": "Prim's Algorithm (and Kruskal's) are used to find minimum spanning trees.",
  "06_30": "Isomorphic graphs have the same structure, even if vertex labels differ.",
  "06_31": "Both trees and graphs are made of vertices and edges.",
  "06_32": "A directed graph has edges that go from one vertex to another (arrows), while undirected edges have no direction.",
  "06_33": "A tree with n vertices always has exactly n-1 edges.",
  "06_34": "In a simple graph, not all vertices must have the same degree.",
  "06_35": "DFS (Depth-First Search) explores all vertices and edges in a systematic way.",
   "06_36": "FSM stands for Finite State Machine, a mathematical model used to represent systems with a finite number of states and rules for transitioning between them.",
  "06_37": "States are the fundamental parts of an FSM. Each state represents a particular situation or configuration that the machine can be in at any moment.",
  "06_38": "Transitions in an FSM are the rules that specify how the machine moves from one state to another, usually based on input symbols.",
  "06_39": "A non-deterministic FSM (NFA) can have multiple possible transitions for the same input and state, while a deterministic FSM (DFA) always has exactly one possible transition for each input and state.",
  "06_40": "Accepting (final) states in an FSM indicate that an input string is accepted by the machine if it ends in one of these states after processing the input.",
  "06_41": "Stacks are not part of a standard FSM. FSMs use only a set of states, an input alphabet, transition functions, a start state, and accepting states. Stacks are used in pushdown automata, not FSMs.",
  "06_42": "In a Mealy machine, the output depends on both the state and the transition taken (input symbol). In a Moore machine, the output depends only on the current state.",
  "06_43": "The start state is the state where the FSM begins before any input is processed. All computation or recognition starts from this state.",
  "06_44": "An accepting state (sometimes called a final state) is a state where, if the machine stops there after reading all input, the string is accepted as belonging to the language.",
  "06_45": "Finite State Machines (FSMs) can recognize regular languages. These are the simplest class of languages and include many useful patterns, such as those used in search functions and regular expressions."
}
